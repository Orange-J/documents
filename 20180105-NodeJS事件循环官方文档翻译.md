# Node.js的事件循环, 定时器和`process.nextTick()`

## 什么是事件循环?

事件循环允许Node.js通过尽可能地分流对系统内核的操作, 来执行 **非阻塞** 的I/O操作, 即使JavaScript是单线程的.

大多数现代的系统内核都是多线程的, 他们在后台可以处理多个同时执行的操作. 当其中一个操作完成时, 系统内核会通知Node.js, 然后与之相关的回调函数会被加入到 **poll队列** 并且最终被执行. 对此本文稍后会详细解释.

## 事件循环说明

当Node.js开始运行时, 它会初始化事件循环, 并执行提供给它的可能调用了异步API, 设置定时器, 或调用了 `process.nextTick()` 的脚本代码(或者进入交互式解释器(REPL), 这种情况并未涵盖在本文中), 然后开始处理事件循环.

下图展示了一个简化后的事件循环操作顺序概览.

```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

*注意: 图中的每个方框被称作事件循环的一个"阶段(phase)"*

每个阶段都有一个先进先出(FIFO)的队列, 里面存放着将要执行的回调函数. 然而每个阶段都有其特殊之处, 通常来讲, 当事件循环进入了某个阶段后, 它可以执行该阶段特有的任意操作, 然后执行该阶段的任务队列中的回调函数, 一直到队列为空或已执行回调的数量达到了允许的最大值. 当队列为空或已执行回调的数量达到了允许的最大值时, 事件循环会进入下一阶段.

由于这些操作中的任意一个都可以调度 **更多的** 操作, 在 **poll(轮询)** 阶段处理的新事件被系统内核加入队列, 当轮询事件正在被处理时新的轮询事件也可以被加入队列. 因此, 长时间运行的回调函数可以让 **poll** 阶段运行的时间比 **timer(计时器)** 的阈值长得多. 查看 **timer** 和 **poll** 部分了解更多细节.

*注意: 在Windows和Unix/Linux实现之间存在一点小小的差异, 但对本示例来说这并不重要. 最重要的部分都已列在这里了. 实际上有7或8个阶段, 但我们关心的和Node.js实际会用到的阶段都已经列在了上面.*

## 阶段概览

- **timers(定时器)** :  此阶段执行那些由 `setTimeout()` 和 `setInterval()` 调度的回调函数.

- **I/O callbacks(I/O回调)** : 此阶段会执行几乎所有的回调函数, 除了 **close callbacks(关闭回调)** 和 那些由 **timers** 与 `setImmediate()` 调度的回调.

- **idle(空转), prepare** : 此阶段只在内部使用

- **poll(轮询)** : 检索新的I/O事件; 在恰当的时候Node会阻塞在这个阶段

- **check** : `setImmediate()` 设置的回调会在此阶段被调用

- **close callbacks(关闭回调)**: 诸如 `socket.on('close', ...)` 此类的回调在此阶段被调用

在事件循环的每次运行之间, Node.js会检查它是否在等待异步I/O或定时器, 如果没有的话就会自动关闭.

## 阶段详情

### timers

一个定时器会指定一个时间阈值, 给定的回调可能会在这个阈值**之后**执行, 而不是在那个精确的时间阈值点执行. 定时器回调将会在给定的时间之后尽可能早地执行; 然而操作系统调度或其他回调的执行可能会**延迟**定时器回调的执行.

*注意: 从技术上来讲, **poll阶段** 会控制定时器何时被执行*.

假如说, 你设定了一个100ms后执行的定时器, 然后你的脚本开始执行一个耗时95ms的异步读取文件的操作:

```
const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);


// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() => {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback < 10) {
    // do nothing
  }
});
```

当事件循环进入 **poll** 阶段, 它有一个空队列(`fs.readFile()`还未完成), 所以它会等待剩余的ms数一直到最近的定时器时间阈值之后. 当它等待了95ms之后, `fs.readFile()`完成了文件读取并且那个要耗时10ms才能完成的回调被加入 **poll** 队列并且执行. 当这个耗时10ms的回调执行结束后, 队列里没有回调了, 因此事件循环会发现最近的定时器时间阈值已经过去了, 然后它返回 **timers** 阶段执行定时器回调. 在这个例子中, 你会发现在设定定时器和该定时器回调被执行之间的时间间隔为105ms.

注意: 为了防止 **poll** 阶段阻塞事件循环, `libuv`(一个实现了Node.js事件循环和Node.js平台所有异步行为的C语言库), 有一个严格的最大限制(这个值取决于操作系统), 在超过此限制后就会停止轮询.

### I/O callbacks

此阶段执行一些系统操作(如各种TCP错误)的回调. 举个例子, 如果一个TCP socket在尝试连接时收到 `ECONNREFUSED` 错误, 一些 *nix 系统会等待报告该错误. 这些操作会被添加到队列并在 **I/O callbacks** 阶段执行.

### poll

**poll** 阶段有两个主要功能:

1. 执行时间阈值已过去的定时器回调, 然后
2. 处理 **poll** 队列中的事件






